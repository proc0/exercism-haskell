
==================== FINAL INTERFACE ====================
2017-11-10 05:20:30.7447686 UTC

interface rotational-cipher-1.1.0.1-9go241enq9zGHpA7gJ72tT:RotationalCipher 8002
  interface hash: 1cdd45bd92567c7aadb9c4f1ceb3c4e0
  ABI hash: 0745588dc95c0b22d05657630ae03157
  export-list hash: 589a0ffd423f6ff241847ed78586e68b
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 1592c852681ff371afa65b2677f320e0
  sig of: Nothing
  used TH splices: False
  where
exports:
  RotationalCipher.rotate
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Char c49b58282af11503cc838e1052cf6b83
import  -/  base-4.9.1.0:GHC.Base 4caea1123ecf4b46e27cbccd6d279377
import  -/  base-4.9.1.0:GHC.Char dc348eccabc798659394eb810444f8d4
import  -/  base-4.9.1.0:GHC.Num 38b8aac8807c096c7f3ca3c1eff02939
import  -/  base-4.9.1.0:GHC.Unicode 7b64ed854a326c2c5bb224f237ed4a0b
import  -/  base-4.9.1.0:Prelude 74b3e204395920329f6de9d97206abe9
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
071197e701a1bb481c53099101aa0c2f
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   RotationalCipher.$trModule2
                   RotationalCipher.$trModule1) -}
bc26f4e2273e0ec5bbf859a83143f9ee
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "RotationalCipher"#) -}
4d4eef834bbc09f4faaf530ff6935b20
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "rotational-cipher-1.1.0.1-9go241enq9zGHpA7gJ72tT"#) -}
f8154191389f2918e7b9921828f50746
  $wrotate :: GHC.Prim.Int# -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: GHC.Base.String) ->
                 case ww of wild {
                   DEFAULT
                   -> GHC.Base.map
                        @ GHC.Types.Char
                        @ GHC.Types.Char
                        (\ (x :: GHC.Types.Char) ->
                         case x of wild1 { GHC.Types.C# c# ->
                         let {
                           x1 :: GHC.Prim.Int# = GHC.Prim.+# wild (GHC.Prim.ord# c#)
                         } in
                         let {
                           i# :: GHC.Prim.Int# = GHC.Prim.-# x1 wild
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.leWord# (GHC.Prim.int2Word# i#) 1114111##) of wild2 {
                           GHC.Types.False -> GHC.Char.chr2 i#
                           GHC.Types.True
                           -> let {
                                c#1 :: GHC.Prim.Char# = GHC.Prim.chr# i#
                              } in
                              case {__pkg_ccall base-4.9.1.0 u_iswlower GHC.Prim.Int#
                                                                        -> GHC.Prim.State#
                                                                             GHC.Prim.RealWorld
                                                                        -> (# GHC.Prim.State#
                                                                                GHC.Prim.RealWorld,
                                                                              GHC.Prim.Int# #)}
                                     (GHC.Prim.ord# c#1)
                                     GHC.Prim.realWorld# of wild3 { (#,#) ds ds1 ->
                              let {
                                $w$j :: GHC.Prim.Void# -> GHC.Prim.Char#
                                  {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
                                = \ (void :: GHC.Prim.Void#)[OneShot] ->
                                  case {__pkg_ccall base-4.9.1.0 u_iswupper GHC.Prim.Int#
                                                                            -> GHC.Prim.State#
                                                                                 GHC.Prim.RealWorld
                                                                            -> (# GHC.Prim.State#
                                                                                    GHC.Prim.RealWorld,
                                                                                  GHC.Prim.Int# #)}
                                         (GHC.Prim.ord# c#1)
                                         GHC.Prim.realWorld# of wild4 { (#,#) ds2 ds3 ->
                                  let {
                                    $w$j1 :: GHC.Prim.Void# -> GHC.Prim.Char#
                                      {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
                                    = \ (void1 :: GHC.Prim.Void#)[OneShot] ->
                                      case ds1 of wild5 {
                                        DEFAULT
                                        -> case GHC.Prim.tagToEnum#
                                                  @ GHC.Types.Bool
                                                  (GHC.Prim.leWord#
                                                     (GHC.Prim.int2Word# x1)
                                                     1114111##) of wild6 {
                                             GHC.Types.False
                                             -> case GHC.Char.chr2 x1 ret_ty GHC.Prim.Char# of {}
                                             GHC.Types.True -> GHC.Prim.chr# x1 }
                                        0#
                                        -> case ds3 of wild6 {
                                             DEFAULT
                                             -> case GHC.Prim.tagToEnum#
                                                       @ GHC.Types.Bool
                                                       (GHC.Prim.leWord#
                                                          (GHC.Prim.int2Word# x1)
                                                          1114111##) of wild7 {
                                                  GHC.Types.False
                                                  -> case GHC.Char.chr2 x1
                                                     ret_ty GHC.Prim.Char#
                                                     of {}
                                                  GHC.Types.True -> GHC.Prim.chr# x1 }
                                             0# -> c#1 } }
                                  } in
                                  case ds3 of wild5 {
                                    DEFAULT
                                    -> case GHC.Prim.tagToEnum#
                                              @ GHC.Types.Bool
                                              (GHC.Prim.># x1 90#) of wild6 {
                                         GHC.Types.False -> $w$j1 GHC.Prim.void#
                                         GHC.Types.True
                                         -> let {
                                              i#1 :: GHC.Prim.Int# = GHC.Prim.-# x1 26#
                                            } in
                                            case GHC.Prim.tagToEnum#
                                                   @ GHC.Types.Bool
                                                   (GHC.Prim.leWord#
                                                      (GHC.Prim.int2Word# i#1)
                                                      1114111##) of wild7 {
                                              GHC.Types.False
                                              -> case GHC.Char.chr2 i#1 ret_ty GHC.Prim.Char# of {}
                                              GHC.Types.True -> GHC.Prim.chr# i#1 } }
                                    0# -> $w$j1 GHC.Prim.void# } }
                              } in
                              case ds1 of wild4 {
                                DEFAULT
                                -> case GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.># x1 122#) of wild5 {
                                     GHC.Types.False
                                     -> case $w$j GHC.Prim.void# of ww1 { DEFAULT ->
                                        GHC.Types.C# ww1 }
                                     GHC.Types.True
                                     -> let {
                                          i#1 :: GHC.Prim.Int# = GHC.Prim.-# x1 26#
                                        } in
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.leWord#
                                                  (GHC.Prim.int2Word# i#1)
                                                  1114111##) of wild6 {
                                          GHC.Types.False -> GHC.Char.chr2 i#1
                                          GHC.Types.True -> GHC.Types.C# (GHC.Prim.chr# i#1) } }
                                0#
                                -> case $w$j GHC.Prim.void# of ww1 { DEFAULT ->
                                   GHC.Types.C# ww1 } } } } })
                        w
                   0# -> w
                   26# -> w }) -}
9b2edb862634c9bf6764d25da5f5e297
  rotate :: GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S(S),1*U(1*U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 RotationalCipher.$wrotate ww1 w1 }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

